;;; evil-easymotion.el --- A port of vim's easymotion to emacs

;; Copyright (C) 2014, 2015, 2016 PythonNut

;; Author: PythonNut <pythonnut@pythonnut.com>
;; Keywords: convenience, evil
;; Version: 20160228
;; URL: https://github.com/pythonnut/evil-easymotion
;; Package-Requires: ((emacs "24") (avy "0.3.0") (cl-lib "0.5"))

;;; License:

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This is a clone of the popular easymotion package for vim, which
;; describes itself in these terms:

;; > EasyMotion provides a much simpler way to use some motions in vim.
;; > It takes the <number> out of <number>w or <number>f{char} by
;; > highlighting all possible choices and allowing you to press one key
;; > to jump directly to the target.

;; If you're having trouble picturing this, please visit the github repo
;; for a screencast.

;; Usage/status
;; ============

;; evil-easymotion, rather unsurprisingly can use evil. However, you don't
;; _need_ evil to use it. evil-easymotion can happily define motions for
;; regular emacs commands. With that said, evil is recommended, not
;; least because it's awesome.

;; Currently most motions are supported, and it's easy to define your own easymotions.

;;   (evilem-define (kbd "SPC w") 'evil-forward-word-begin)

;; To define easymotions for all motions that evil defines by default, add

;;   (evilem-default-keybindings "SPC")

;; This binds all motions under the prefix `SPC` in `evil-motion-state-map`. This is not done by default for motions defined manually. You will need to supply the prefix.

;; More advanced use-cases are detailed in the github README.

;;; Code:
(require 'cl-lib)

(eval-when-compile
  (require 'avy)
  (require 'evil))

(defgroup evilem nil
  "Emulate vim-easymotion"
  :group 'convenience
  :prefix "evilem-")

(defcustom evilem-keys nil
  "Value of `avy-keys' to set during motions. Set to nil to leave unchanged."
  :type '(repeat :tag "Keys" character))

(defcustom evilem-style nil
  "Value of `avy-style' to set during motions. Set to nil to leave unchanged."
  :type '(choice
          (const :tag "Pre" pre)
          (const :tag "At" at)
          (const :tag "At Full" at-full)
          (const :tag "Post" post)
          (const :tag "De Bruijn" de-bruijn)
          (const :tag "Default" nil)))

;; macro helper, from evil source
(eval-and-compile
  (defun evilem--unquote (exp)
    "Return EXP unquoted."
    (while (member (car-safe exp) '(quote function))
      (setq exp (cadr exp)))
    exp)

  (defun evilem--make-name (func)
    (format "evilem--motion-%s"
            (if (functionp func)
                (symbol-name (evilem--unquote func))
              (mapconcat (lambda (f)
                           (symbol-name (evilem--unquote f)))
                         func
                         "-")))))

(defun evilem--jump (points)
  "avy-jump to the set of points generated by collector"
  (require 'avy)
  (let* ((avy-style (or evilem-style avy-style))
         (avy-keys (or evilem-keys avy-keys)))
    (avy--process points
                  (avy--style-fn avy-style))))

(defun evilem--default-collect-postprocess (points)
  (cl-stable-sort
   points
   #'<
   :key (lambda (pt)
          (if (equal (selected-window) (cdr pt))
              (abs (- (point) (car pt)))
            most-positive-fixnum))))

(defun evilem--collect (func &optional
                             scope
                             all-windows
                             initial-point
                             sort-key
                             collect-postprocess)
  "Repeatedly execute func, and collect the cursor positions into a list"
  (cl-letf ((points nil)
            (point nil)
            (avy-all-windows all-windows)
            ;; make sure the motion doesn't move the window
            (scroll-conservatively 101)
            (smooth-scrolling-mode nil)
            (scroll-margin 0))
    (if (functionp func)
        (avy-dowindows current-prefix-arg
          (save-excursion
            (save-restriction
              (when initial-point
                (goto-char (funcall initial-point)))
              (cl-destructuring-bind (beg . end)
                  (if scope
                      (bounds-of-thing-at-point scope)
                    (cons (point-min)
                          (point-max)))

                ;; trim trailing newline
                (when (= (char-before end) 10)
                  (cl-decf end))

                (narrow-to-region (max beg (window-start))
                                  (min end (window-end))))
              (while (and (ignore-errors
                            (setq this-command func
                                  last-command func)
                            (call-interactively func)
                            t)
                          (setq point (cons (point) (get-buffer-window)))
                          (not (member point points))
                          (push point points))))))
      (setq points (cl-remove-duplicates
                    (cl-mapcan (lambda (f)
                                 (evilem--collect f scope all-windows))
                               func))))
    (funcall (or collect-postprocess
                 #'evilem--default-collect-postprocess)
             points)))

(defun evilem--compute-inclusivity (funcs)
  (when (and (= (length funcs) 1)
             (evil-has-command-properties-p (car funcs)))
    `(setq evil-this-type
           ',(evil-get-command-property (car funcs) :type))))

(cl-defmacro evilem-make-motion (name
                                 funcs
                                 &key
                                 pre-hook
                                 post-hook
                                 bind
                                 scope
                                 all-windows
                                 initial-point
                                 push-jump
                                 collect-postprocess)
  "Automatically define an evil easymotion for `func', naming it `name'"
  `(,(if all-windows
         'evil-define-command
       'evil-define-motion)
    ,name (&optional _count)
    (require 'avy)
    (avy-with ,name
      (evil-without-repeat
        ,(evilem--compute-inclusivity funcs)
        (cl-letf* ,bind
          ,(when (or push-jump (not scope))
             '(evil--jumps-push))
          ,(when pre-hook `(funcall ,(if (functionp pre-hook)
                                         pre-hook
                                       `(lambda () ,pre-hook))))
          (evilem--jump (evilem--collect ,funcs
                                         ,scope
                                         ,all-windows
                                         ,initial-point
                                         ,collect-postprocess))
          ,(when post-hook `(funcall ,(if (functionp post-hook)
                                          post-hook
                                        `(lambda () ,post-hook)))))))))

(cl-defmacro evilem-make-motion-plain (name
                                       funcs
                                       &key
                                       pre-hook
                                       post-hook
                                       bind
                                       scope
                                       all-windows
                                       initial-point
                                       collect-postprocess)
  "Automatically define a plain easymotion for `func', naming it `name'"
  `(defun ,name ()
     (interactive)
     (require 'avy)
     (avy-with ,name
       (cl-letf* ,bind
         ,(when pre-hook `(funcall ,(if (functionp pre-hook)
                                        pre-hook
                                      `(lambda () ,pre-hook))))
         (evilem--jump (evilem--collect ,funcs
                                        ,scope
                                        ,all-windows
                                        ,initial-point
                                        ,collect-postprocess))
         ,(when post-hook `(funcall ,(if (functionp post-hook)
                                         post-hook
                                       `(lambda () ,post-hook))))))))

(cl-defmacro evilem-create (motions
                            &key
                            name
                            pre-hook
                            post-hook
                            bind
                            scope
                            all-windows
                            initial-point
                            push-jump
                            collect-postprocess)
  `(evilem-make-motion
    ,(or (evilem--unquote name)
         (intern (evilem--make-name motions)))
    ,motions
    :pre-hook ,pre-hook
    :post-hook ,post-hook
    :bind ,bind
    :scope ,scope
    :all-windows ,all-windows
    :initial-point ,initial-point
    :push-jump ,push-jump
    :collect-postprocess ,collect-postprocess))

(cl-defmacro evilem-create-plain (motions
                                  &key
                                  name
                                  pre-hook
                                  post-hook
                                  bind
                                  scope
                                  all-windows
                                  initial-point
                                  collect-postprocess)
  `(evilem-make-motion-plain
    ,(or (evilem--unquote name)
         (intern (evilem--make-name motions)))
    ,motions
    :pre-hook ,pre-hook
    :post-hook ,post-hook
    :bind ,bind
    :scope ,scope
    :all-windows ,all-windows
    :initial-point ,initial-point
    :collect-postprocess ,collect-postprocess))

(cl-defmacro evilem-define (key
                            motions
                            &key
                            name
                            pre-hook
                            post-hook
                            bind
                            scope
                            all-windows
                            initial-point
                            push-jump
                            collect-postprocess)
  "Automatically create and bind an evil motion"
  `(define-key ,(if all-windows
                    'evil-normal-state-map
                  'evil-motion-state-map)
     ,key
     (evilem-create ,motions
                    :name ,name
                    :pre-hook ,pre-hook
                    :post-hook ,post-hook
                    :bind ,bind
                    :scope ,scope
                    :all-windows ,all-windows
                    :initial-point ,initial-point
                    :push-jump ,push-jump
                    :collect-postprocess ,collect-postprocess)))

;;;###autoload
(defun evilem-default-keybindings (prefix)
  "Define easymotions for all motions evil defines by default"
  (define-key evil-motion-state-map (kbd prefix) nil)
  (evilem-define (kbd (concat prefix " w")) #'evil-forward-word-begin
                 :scope 'line)
  (evilem-define (kbd (concat prefix " W")) #'evil-forward-WORD-begin
                 :scope 'line)
  (evilem-define (kbd (concat prefix " e")) #'evil-forward-word-end
                 :scope 'line)
  (evilem-define (kbd (concat prefix " E")) #'evil-forward-WORD-end
                 :scope 'line)
  (evilem-define (kbd (concat prefix " b")) #'evil-backward-word-begin
                 :scope 'line)
  (evilem-define (kbd (concat prefix " B")) #'evil-backward-WORD-begin
                 :scope 'line)
  (evilem-define (kbd (concat prefix " ge")) #'evil-backward-word-end
                 :scope 'line)
  (evilem-define (kbd (concat prefix " gE")) #'evil-backward-WORD-end
                 :scope 'line)

  (evilem-define (kbd (concat prefix " j")) #'next-line
                 :pre-hook (setq evil-this-type 'line)
                 :bind ((temporary-goal-column (current-column))
                        (line-move-visual nil)))

  (evilem-define (kbd (concat prefix " k")) #'previous-line
                 :pre-hook (setq evil-this-type 'line)
                 :bind ((temporary-goal-column (current-column))
                        (line-move-visual nil)))

  (evilem-define (kbd (concat prefix " g j")) #'next-line
                 :pre-hook (setq evil-this-type 'line)
                 :bind ((temporary-goal-column (current-column))
                        (line-move-visual t)))

  (evilem-define (kbd (concat prefix " g k")) #'previous-line
                 :pre-hook (setq evil-this-type 'line)
                 :bind ((temporary-goal-column (current-column))
                        (line-move-visual t)))

  (evilem-define (kbd (concat prefix " t")) #'evil-repeat-find-char
                 :name 'evilem--motion-evil-find-char-to
                 :pre-hook (save-excursion
                             (setq evil-this-type 'inclusive)
                             (call-interactively #'evil-find-char-to))
                 :bind ((evil-cross-lines t)))

  (evilem-define (kbd (concat prefix " T")) #'evil-repeat-find-char
                 :name 'evilem--motion-evil-find-char-to-backward
                 :pre-hook (save-excursion
                             (setq evil-this-type 'exclusive)
                             (call-interactively #'evil-find-char-to-backward))
                 :bind ((evil-cross-lines t)))

  (evilem-define (kbd (concat prefix " f")) #'evil-repeat-find-char
                 :name 'evilem--motion-evil-find-char
                 :pre-hook (save-excursion
                             (setq evil-this-type 'inclusive)
                             (call-interactively #'evil-find-char))
                 :bind ((evil-cross-lines t)))

  (evilem-define (kbd (concat prefix " F")) #'evil-repeat-find-char
                 :name 'evilem--motion-evil-find-char-backward
                 :pre-hook (save-excursion
                             (setq evil-this-type 'exclusive)
                             (call-interactively #'evil-find-char-backward))
                 :bind ((evil-cross-lines t)))

  (evilem-define (kbd (concat prefix " [[")) #'evil-backward-section-begin
                 :pre-hook (setq evil-this-type 'line))

  (evilem-define (kbd (concat prefix " []")) #'evil-backward-section-end
                 :pre-hook (setq evil-this-type 'line))

  (evilem-define (kbd (concat prefix " ]]")) #'evil-forward-section-begin
                 :pre-hook (setq evil-this-type 'line))

  (evilem-define (kbd (concat prefix " ][")) #'evil-forward-section-end
                 :pre-hook (setq evil-this-type 'line))

  (evilem-define (kbd (concat prefix " (")) #'evil-backward-sentence-begin)
  (evilem-define (kbd (concat prefix " )")) #'evil-forward-sentence-begin)

  (evilem-define (kbd (concat prefix " n")) #'evil-search-next
                 :bind (((symbol-function #'isearch-lazy-highlight-update)
                         #'ignore)
                        (search-highlight nil)))
  (evilem-define (kbd (concat prefix " N")) #'evil-search-previous
                 :bind (((symbol-function #'isearch-lazy-highlight-update)
                         #'ignore)
                        (search-highlight nil)))
  (evilem-define (kbd (concat prefix " *")) #'evil-search-word-forward
                 :bind (((symbol-function #'isearch-lazy-highlight-update)
                         #'ignore)
                        (search-highlight nil)))
  (evilem-define (kbd (concat prefix " #")) #'evil-search-word-backward
                 :bind (((symbol-function #'isearch-lazy-highlight-update)
                         #'ignore)
                        (search-highlight nil)))

  (evilem-define (kbd (concat prefix " -"))
                 #'evil-previous-line-first-non-blank)
  (evilem-define (kbd (concat prefix " +"))
                 #'evil-next-line-first-non-blank))

(provide 'evil-easymotion)
;;; evil-easymotion.el ends here
